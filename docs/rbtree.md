[toc]

## 红黑树的规则

1. 节点为红色或黑色
2. 根节点必须为黑色
3. NIL 节点（空叶子节点）为黑色
4. 红色节点的子节点为黑色
5. 从根节点到 NIL 节点的每条路径上的黑色节点数量相同

1. A node is either red or black
2. The root is black
3. All leaves (NULL) are black
4. Both children of every red node are black
5. Every simple path from root to leaves contains the same number of black nodes.

## 红黑树的插入

> 小写字母为红色，大写字母为黑色

### case 1
树为空，直接插入作为根节点

### case 2
插入节点的父节点为黑色，直接插入，无需调整

### case 3
插入节点的父节点和叔节点均为红色

此种情况祖父节点一定为黑色
将父节点和叔节点染成黑色，祖父节点染成红色，递归维护祖父节点

```cpp
/**
      G             g
     / \           / \
    p   u  -->    P   U
     \             \ 
      n             n

      G             g
     / \           / \
    p   u  -->    P   U
   /             /
  n             n

      G             g
     / \           / \
    u   p  -->    U   p
         \             \ 
          n             n

      G             g
     / \           / \
    u   p  -->    U   P
       /             /
      n             n
**/
```



### Case 4

(Case4总是从Case3转来的，正常插入不会出现Case4的情况)

插入节点的父节点和叔节点均为黑色

1. 父节点为祖父节点的左子结点，插入节点为父节点的右子节点(LR形式)

先左旋

```cpp
/**
      G             G
     / \           / \
    p   U  -->    n   U
     \           /
      n         p
**/
```

再右旋

```cpp
/**
        G           P
       / \         / \
      p   U  -->  n   g
     /                 \
    n                   U
**/
```

2. 父节点为祖父节点的右子结点，插入节点为父节点的左子节点(RL形式)

先右旋
```cpp
/**
      G             G
     / \           / \
    U   p  -->    U   p
       /              \ 
      n                n 
**/
```
再左旋
```cpp
/**
        G           P
       / \         / \
      U   p  -->  g   n
          \      /      
           n    U
**/
```

### case 5

(Case5总是从Case3或Case4转来的，正常插入不会出现Case5的情况)

插入节点的父节点和叔节点均为黑色

1. 父节点为祖父节点的左子结点，插入节点为父节点的左子节点(LL形式)

右旋
```cpp
/**
          G             P
         / \           / \
        p   U  -->    n   g
       /                  \ 
      n                    U 
**/
```

2. 父节点为祖父节点的右子结点，插入节点为父节点的右子节点(RR形式)

左旋
```cpp
/**
        G           P
       / \         / \
      U   p  -->  g   n
          \      /      
           n    U
**/
```

## 红黑树的删除

### Case 1 

待删除的节点为叶子节点(node->left == NULL && node->right == NULL)

- 如果为红色，直接删除，后续不需要维护
- 如果为黑色，直接删除，后续需要维护

### Case 2

待删除的节点有一个子节点，另一个子结点为空

根据规则4),5)，该节点一定为黑色,其子结点一定为红色

删除时，使用子结点替换待删除节点，并将子结点染黑，无需维护(将子结点染黑也是一种维护，只是不需要延后维护)

### Case 3

待删除的节点有两个子结点

将该节点与其后继节点(successor)交换，交换后删除该节点, **successor继承待删除节点的颜色**(相当于只交换节点中保存的值)
(后继节点：节点的右子树上的最左节点，后继节点无左子结点，可能有右子结点)

#### 后继节点有右子结点

如果后继节点有右子结点，**只需将其右子结点染黑**，
无需维护（将右子结点染黑也是一种维护，不过因为简单，不必延后至维护阶段）
原因如下：

```cpp
// 使用最简单的情况(待删除节点的后继节点就是其右子结点)说明原因,
// 其他情况同理

/**
    n/N : 待删除节点
    l/L : 待删除节点的左子结点
    s/S : 后继节点
    c/C : 后继节点的右子结点
*/

// 1. n为红色，则L和S必须为黑色，c必须为红色(如图(1)所示)
// 删除n后变为图(2),此时只需将c染黑即可满足规则(图(3))
/**
        n           S           S
       / \         / \         / \
      L   S  -->  L   c  -->  L   C
           \            
            c    
       (1)          (2)         (3)
*/

/*
2. n为黑色, 根据规则4), 5), s,c中一定一红一黑,所以L一定为黑色(如图(1))
则可分为两种情况：S黑c红(图(2))，s红C黑(图(3))
S黑c红：
    删除N后，由(2)->(4), 此时c为红，违反规则5), 只需将c染黑即可满足规则
s红C黑：
    删除N后，由(2)->(6), 图(6)已经满足规则，无需任何操作
*/
/**
        N           N           N
       / \         / \         / \
      L  (s)      L   S       L   s
           \           \           \
           (c)          c           C
       (1)          (2)         (3)

        N           S           S
       / \         / \         / \
      L   S  -->  L   c  -->  L   C
           \            
            c            
        (2)         (4)        (5)

        N           s  
       / \         / \ 
      L   s  -->  L   C
           \           
            C          
        (3)         (6)

*/
```
综上所述，待删除节点有两个子结点时，如果后继节点有右子结点，**只需将其右子结点染黑**，

#### 后继节点无右子结点

如果后继节点无右子节点，根据待删除节点的颜色决定是否需要维护
    - 若待删除节点为红色，不需要维护，
    - 若待删除节点为黑色，需要维护，


## 红黑树删除后的维护

由上述红黑树的节点删除操作可知，只有在删除黑色节点后需要维护
删除一个黑色节点，会导致删除节点的左右子树上的节点的黑深度减一,不满足性质5)

N 节点，待删除节点
P 节点，父亲节点
S 节点，兄弟节点
C 节点，近侄子节点
D 节点，远侄子节点

若N为P的左子结点，删除N节点后，需要根据P、S、C、D节点的颜色情况进行维护，
考虑红黑树的性质后，可计算得出共有9种情况
N为右子结点时同上

### Case 1
(1种)
P为黑色
S为红色
C为黑色
D为黑色
```cpp

/**
        P           s          S  
       / \         / \        / \ 
      N   s  -->  P   D -->  p   D
         / \     / \        / \   
        C   D   N   C      N   C  
**/

```

1. 先左旋P节点
2. 将S染黑, P 染红
3. 此时，以P为根节点的子树在删除N后仍不满足性质5)，在以P为根的子树中
继续维护N节点

### Case 2
(1种)
P为红色
S为黑色
C为黑色
D为黑色
```cpp

/**
        p           P    
       / \         / \   
      N   S  -->  N   s 
         / \         / \   
        C   D       C   D  
**/

```
最简单的情况
只需将p染黑，S染红，即可满足性质5)

### Case 3

(1种)
P为黑色
S为黑色
C为黑色
D为黑色
```cpp

/**
        P           P    
       / \         / \   
      N   S  -->  N   s 
         / \         / \   
        C   D       C   D  
**/

```

1. 将S节点染红，
此时以P为根的子树已经满足性质5，但是这颗子树上的节点的黑深度都减小1，
所以以P的父节点为根的子树可能违背性质5, 所以将P节点作为N节点递归维护,
如果P是根节点则不需要递归维护

### Case 4

(Case4总是从Case3转来的)

(2种)
P为红色或黑色
S为黑色
C为红色
D为黑色

```cpp

/**
       (p)         (p)              (p)       
       / \         / \              / \       
      N   S  -->  N   c      -->   N   C      
         / \           \                \     
        c   D           S                s    
                         \                \   
                          D                D  
**/                                           

```
1. 右旋S节点
2. 将c染黑，S染红
3. 此时仍不满足性质5, 不过当前情况符合Case5,可以转到Case5处理


### Case 5

(4种)
P为红色或黑色
S为黑色
C为红色或黑色
D为红色

```cpp

/**
       (p)          S           (s)       
       / \         / \          / \       
      N   S  --> (p)  d  -->   P   D
         / \     / \          / \      
       (c)  d   N  (c)       N  (c)    
                                       
                                       
**/                                           

```
1. 左旋(p)                      (N子树黑深度+1,   (c)子树黑深度不变，d子树黑深度-1)
2. 交换(p)和S的颜色，将d染黑    (N子树黑深度不变，(c)子树黑深度不变，D子树黑深度+1)

有上可知，将N删除后，N、C、D子树黑深度与原来相同
