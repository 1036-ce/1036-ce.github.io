## 非递归 树的遍历

### 前序遍历
```cpp
vector<int> preorderTraversal(TreeNode *root) {
    TreeNode *node = root;
    stack<TreeNode*> st;
    vector<int> ans;

    while (node != nullptr || !st.empty()) {
        while (node) {
            st.push(node);
            ans.push_back(node->val);
            node = node->left;
        }
        node = st.top();
        st.pop();
        node = node->right;
    }
    return ans;
}
```

```cpp
// 代码有点像层序遍历，不过把queue换成了stack
// 只有前序遍历可以这样做，中序和后序都不行
vector<int> preorderTraversal(TreeNode *root) {
    if (root == nullptr) {
        return {};
    }
    vector<int> ans;
    stack<TreeNode*> st;
    st.push(root);

    while (!st.empty()) {
        root = st.top();
        st.pop();
        ans.push_back(root->val);
        if (root->right) {
            st.push(root->right);
        }
        if (root->left) {
            st.push(root->left);
        }
    }
    return ans;
}
```

### 中序遍历
```cpp
vector<int> inorderTraversal(TreeNode *root) {
    TreeNode *node = root;
    stack<TreeNode*> st;
    vector<int> ans;

    while (node != nullptr || !st.empty()) {
        while (node) {
            st.push(node);
            node = node->left;
        }
        node = st.top();
        st.pop();
        ans.push_back(node->val);
        node = node->right;
    }
    return ans;
}
```

### 后序遍历

```cpp
vector<int> postorderTraversal(TreeNode *root) {
    TreeNode *node = root;
    stack<TreeNode*> st;
    vector<int> ans;

    // prev 表示上一个遍历完成的子树的根节点
    TreeNode *prev = nullptr;
    while (node != nullptr || !st.empty()) {
        while (node) {
            st.push(node);
            node = node->left;
        }
        node = st.top();
        st.pop();
        if (node->right == nullptr || node->right == prev) {
            ans.push_back(node->val);
            prev = node;
            node = nullptr;  // 表明以node为根的子树已经遍历完成, 下次循环应该出栈
        }
        else {
            st.push(node);
            node = node->right;
        }
    }
    return ans;
}
```
