# 协程理论

**本文翻译自[原文](https://lewissbaker.github.io/2017/09/25/coroutine-theory#coroutines-are-functions-are-coroutines)**

这是一系列关于C++协程TS的文章的第一篇，[C++协程TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf)是一种新的语言特性，目前正在计划中并将被纳入C++20语言标准。

在这个系列中，我将介绍C++协程的底层机制，以及展示它们如何被用来构建有用的高级抽象，比如[cppcoro](https://github.com/lewissbaker/cppcoro)库提供的那些抽象。

在本文中，我将描述函数和协程之间的区别，并提供关于它们支持的操作的一些理论知识。本文的目的是介绍一些基础概念，帮助你理解C++协程的工作方式。

## 协程是函数，函数是协程

协程是对函数的一种泛化，它允许函数在执行过程中被暂停，然后稍后再恢复执行。

我将稍后详细解释这是什么意思，但在此之前，我想先回顾一下一个“普通”C++函数是如何工作的。

## “正常的”函数

一个普通函数可以认为有两个操作：调用和返回（请注意，我将“抛出异常”广义地归为返回操作）。

调用操作创建一个*激活帧*，暂停*调用函数*的执行，并将执行转移到*被调用函数*的开始处。

返回操作将返回值传递给*调用者*，销毁*激活帧*，然后恢复*调用者*的执行，恢复到调用函数的地方之后的执行点。

让我们对这些语义进行更详细的分析…

### 激活帧

那么什么是“激活帧”？

你可以把激活帧想象成保存特定函数调用当前**状态**的内存块。这个状态包括传递给函数的s所有参数的值以及所有局部变量的值。

对于“普通”函数来说，激活帧还包括返回地址--即返回函数时要转移到的指令的地址--以及调用函数的激活帧的地址。你可以将这些信息一起看作是描述函数调用的‘延续’。也就是说，它们描述了在函数完成时哪个函数调用的哪个调用应该在哪个点继续执行。

对于“普通”函数，所有激活帧的生命周期严格嵌套。这种严格嵌套允许使用一种高效的内存分配数据结构来分配和释放每个函数调用的激活帧。这种数据结构通常称为“堆栈”。

当在这个堆栈数据结构上分配激活帧时，通常称为“堆栈帧”。

这种堆栈数据结构是如此常见，以至于大多数（所有？）CPU架构都有一个专门的寄存器来保存指向堆栈顶部的指针（例如，在X64中，它是rsp寄存器）。

要为新的激活帧分配空间，只需将该寄存器增加帧大小。要释放激活帧的空间，只需将该寄存器减去帧大小。


### 调用操作

当一个函数调用另一个函数时，调用者必须首先准备好自己以便被挂起。

这个“挂起”步骤通常涉及将当前保存在CPU寄存器中的任何值保存到内存中，以便在函数恢复执行时，这些值可以被恢复。根据函数的调用约定，调用者和被调用者可能会协调谁保存这些寄存器的值，但你仍然可以将它们视为调用操作的一部分。

调用者还将传递给被调用函数的所有参数的值存储到新的激活帧中，在那里它们可以被该函数访问。

最后，调用者将自己的恢复点地址写入新的激活帧，并将执行转移到被调用函数的开始处。

在X86/X64架构中，这个最后的操作有它自己的指令，即`call`指令，它将下一条指令的地址写入堆栈，将堆栈寄存器增加地址的大小，然后跳转到指令操作数中指定的地址。

### 返回操作

当一个函数通过`return`语句返回时，函数首先将返回值（如果有的话）存储在调用者可以访问的地方。这可以是在调用者的激活帧中，也可以是在函数的激活帧中（对于跨越两个激活帧之间边界的参数和返回值，这个区别可能会有些模糊）。

然后，函数通过以下步骤销毁激活帧：

1. 销毁返回点处仍在作用域中的任何局部变量。
2. 销毁任何参数对象。
3. 释放激活帧使用的内存。
4. 最后，函数通过以下步骤恢复调用者的执行：

通过设置堆栈寄存器指向调用者的激活帧并恢复可能被函数破坏的任何寄存器，来恢复调用者的激活帧。
跳转到在“调用”操作期间存储的调用者的恢复点。
请注意，与“调用”操作一样，一些调用约定可能会将“返回”操作的责任分散在调用者和被调用函数的指令之间。

## 协程

协程通过将在调用和返回操作中执行的一些步骤分离出来，将函数的操作进行泛化，引入了三个额外的操作：挂起（Suspend）、恢复（Resume）和销毁（Destroy）。

1. **挂起（Suspend）**操作在函数内部的当前点挂起协程的执行，并将执行转移到调用者或恢复者，而不销毁激活帧。在挂起点处仍在作用域内的任何对象在协程执行暂停后仍然保持活动状态。

请注意，类似于函数的返回操作，协程只能在定义明确的挂起点处从协程内部挂起。

2. **恢复（Resume）**操作在协程被挂起的点处恢复协程的执行。这会重新激活协程的激活帧。

3. **销毁（Destroy）**操作在不恢复协程执行的情况下销毁激活帧。在挂起点处仍然在作用域内的任何对象都将被销毁。用于存储激活帧的内存将被释放。

### 协程激活帧

由于协程可以在不销毁激活帧的情况下挂起，我们不能再保证激活帧的生命周期会严格嵌套。这意味着激活帧通常无法使用堆栈数据结构分配，而可能需要存储在**堆**上。

在C++协程TS中有一些规定，允许在编译器能够证明协程的生命周期确实严格嵌套在调用者的生命周期内时，从调用者的激活帧中分配协程帧的内存。这在许多情况下可以避免堆分配，前提是你有一个足够智能的编译器。

使用协程时，激活帧中有一些部分需要在协程挂起时保留，而有些部分只需要在协程执行时保留。例如，具有不跨越任何协程挂起点的作用域的变量的生命周期可能可以存储在**栈**上。

你可以将协程的激活帧逻辑地看作由两部分组成：**‘协程帧’**和**‘堆栈帧’**。

**‘协程帧’**持有协程挂起时持续存在的部分激活帧，
而**‘堆栈帧’**部分仅在协程执行时存在，并在协程挂起时释放，并将执行转移到调用者/恢复者。

### 挂起操作

协程的挂起操作允许协程在函数的中间挂起执行，并将执行转移到协程的调用者或恢复者。

协程体内部的某些点被指定为挂起点。在C++协程TS中，这些挂起点通过使用`co_await`或`co_yield`关键字来标识。

当协程命中这些挂起点时，首先要准备协程以便恢复：

1. 确保寄存器中保存的值被写入协程帧。
2. 向协程帧写入一个值，指示协程被挂起的挂起点。这样可以让后续的Resume操作知道在哪个挂起点恢复协程的执行，或让后续的Destroy操作知道在作用域内的哪些值需要被销毁。

一旦协程做好恢复的准备，协程就被认为是‘挂起’状态。

**然后，协程有机会在将执行转移到调用者/恢复者之前执行一些附加逻辑。这些附加逻辑可以访问一个指向协程帧的句柄，该句柄可以在以后用于恢复或销毁协程。**

协程进入‘挂起’状态后执行逻辑的能力，使得协程可以在不需要同步的情况下安排恢复。如果协程在进入‘挂起’状态之前被安排恢复，那么协程的挂起和恢复可能会发生竞争，从而需要同步，我会在以后的文章中详细介绍。

然后，协程可以选择立即恢复/继续执行协程，或者选择将执行转移到调用者/恢复者。

如果将执行转移到调用者/恢复者，则协程的堆栈帧部分将被释放并从堆栈中弹出。

### 恢复操作

Resume操作可以在当前处于“挂起”状态的协程上执行。

当一个函数想要恢复一个协程时，它需要有效地“调用”到特定函数调用的中间位置。恢复者确定要恢复的特定调用的方式是调用协程帧句柄上提供的`void resume()`方法，该方法由相应的挂起操作提供。

就像普通函数调用一样，对`resume()`的调用将在转移执行到函数之前分配一个新的堆栈帧，并将调用者的返回地址存储在堆栈帧中。

然而，与将执行转移到函数的开始处不同，它将执行转移到函数被最后挂起的地方。它通过从协程帧加载恢复点并跳转到该点来实现这一点。

当协程下次挂起或执行完成时，对resume()的调用将返回并恢复调用函数的执行。


### 销毁操作

销毁操作在不恢复协程执行的情况下销毁协程帧。

此操作只能在挂起的协程上执行。

销毁操作的作用类似于Resume操作，因为它重新激活了协程的激活帧，包括分配一个新的堆栈帧并存储销毁操作的调用者的返回地址。

然而，与将执行转移到协程体的最后挂起点不同，它转移到一个另一个代码路径，该路径调用挂起点处作用域内 **所有局部变量的析构函数**，然后释放协程帧使用的内存。

与Resume操作类似，Destroy操作通过在相应的挂起操作期间提供的协程帧句柄上调用`void destroy()`方法来确定要销毁的特定激活帧。


### 协程的调用操作

协程的调用操作与普通函数的调用操作基本相同。事实上，从调用者的角度来看，没有区别。

然而，与仅在函数运行完成时才返回到调用者不同，对于协程，调用操作将在协程达到其第一个挂起点时恢复调用者的执行。

当在协程上执行调用操作时，调用者分配一个新的堆栈帧，将参数写入堆栈帧，将返回地址写入堆栈帧，并将执行转移到协程。这与调用普通函数完全相同。

然后，协程首先在堆上分配一个协程帧，并将参数从堆栈帧复制/移动到协程帧中，以便参数的生命周期延伸到第一个挂起点之后。

### 协程的返回操作

协程的返回操作与普通函数的返回操作略有不同。

当一个协程执行返回语句（根据TS，是co_return操作）时，它会将返回值存储在某个地方（这个存储位置可以由协程自定义），然后销毁任何作用域内的局部变量（但不包括参数）。

然后，协程有机会在将执行转移到调用者/恢复者之前执行一些附加逻辑。

这些附加逻辑可能执行某些操作以发布返回值，或者可能恢复另一个正在等待结果的协程。这完全是可定制的。

然后，协程执行挂起操作（保持协程帧活动）或销毁操作（销毁协程帧）。

执行然后根据挂起/销毁操作的语义返回给调用者/恢复者，并将激活帧的堆栈帧组件从堆栈中弹出。

值得注意的是，传递给返回操作的返回值与从调用操作返回的返回值不同，因为返回操作可能在调用者从初始调用操作恢复后很长时间才执行。

## 一个插图

为了帮助将这些概念形象化，我想通过一个简单的示例来说明当协程被调用、挂起和稍后恢复时会发生什么。

假设我们有一个函数（或协程）`f()`，它调用了一个协程`x(int a)`。

在调用之前，我们的情况类似于这样：

```
STACK                     REGISTERS               HEAP

                          +------+
+---------------+ <------ | rsp  |
|  f()          |         +------+
+---------------+
| ...           |
|               |
```

然后当`x(42)`被调用时，他首先为`x()`创建一个栈帧，就像一个普通函数做的那样

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |
| ret= f()+0x123 |   |    +------+
+----------------+   +--- | rsp  |
|  f()           |        +------+
+----------------+
| ...            |
|                |
```

然后，一旦协程x()在堆上为协程帧分配了内存，并将参数值复制/移动到协程帧中，我们将得到类似下图的情况。请注意，编译器通常会将协程帧的地址保存在一个单独的寄存器中，与堆栈指针分开（例如，MSVC将其存储在rbp寄存器中）。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     +-----------+
+----------------+        | rbp  | ------+
| ...            |        +------+
|                |
```

如果协程x()然后调用另一个普通函数g()，情况将类似于这样：

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  g()           |   |
| ret= x()+0x45  |   |
+----------------+   |
|  x()           |   |
| coroframe      | --|-------------------+
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+             |  x()      |
+----------------+   +--- | rsp  |             | a =  42   |
|  f()           |        +------+             +-----------+
+----------------+        | rbp  |
| ...            |        +------+
|                |
```

当g()返回时，它将销毁自己的激活帧并恢复x()的激活帧。假设我们将g()的返回值保存在一个名为b的局部变量中，该变量存储在协程帧中。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     | b = 789   |
+----------------+        | rbp  | ------+     +-----------+
| ...            |        +------+
|                |
```

如果`x()`现在遇到一个挂起点，并且在不销毁其激活帧的情况下暂停执行，那么执行将返回到`f()`。

这导致`x()`的堆栈帧部分从堆栈中弹出，同时将协程帧保留在堆上。当协程第一次暂停时，会向调用者返回一个返回值。这个返回值通常保存着一个句柄，指向了暂停的协程帧，以便稍后恢复它。当`x()`暂停时，它还会在协程帧中存储x()的恢复点的地址（称为RP，即恢复点）。

```
STACK                     REGISTERS               HEAP
                                        +----> +-----------+
                          +------+      |      |  x()      |
+----------------+ <----- | rsp  |      |      | a =  42   |
|  f()           |        +------+      |      | b = 789   |
| handle     ----|---+    | rbp  |      |      | RP=x()+99 |
| ...            |   |    +------+      |      +-----------+
|                |   |                  |
|                |   +------------------+
```

这个句柄现在可以像普通值一样在函数之间传递。在稍后的某个时刻，可能是从不同的调用堆栈甚至在不同的线程上，某个东西（比如，`h()`）会决定恢复该协程的执行，例如，当一个异步I/O操作完成时。

恢复协程的函数调用了一个名为`void resume(handle)`的函数来恢复协程的执行。对于调用者来说，这看起来就像对带有单个参数的void返回函数的任何其他普通调用。

这会创建一个新的堆栈帧，记录调用`resume()`的调用者的返回地址，通过将其地址加载到寄存器中激活协程帧，并在协程帧中存储的恢复点处恢复`x()`的执行。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |                   +-->  +-----------+
| ret= h()+0x87  |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  h()           |        +------+       |     | b = 789   |
| handle         |        | rbp  | ------+     +-----------+
+----------------+        +------+
| ...            |
|                |
```

## 总结

我已经描述了协程作为函数的一种泛化，它具有三个额外的操作——“挂起”、“恢复”和“销毁”，除了“普通”函数提供的“调用”和“返回”操作。

我希望这提供了一些有用的思维框架，帮助理解协程及其控制流。

在下一篇文章中，我将介绍C++协程TS语言扩展的机制，并解释编译器如何将您编写的代码转换为协程。




